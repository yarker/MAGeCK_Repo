#!/usr/bin/env python
"""MAGeCK file operation module
Copyright (c) 2014 Wei Li, Han Xu, Xiaole Liu lab 
This code is free software; you can redistribute it and/or modify it
under the terms of the BSD License (see the file COPYING included with
the distribution).
@status:  experimental
@version: $Revision$
@author:  Wei Li 
@contact: li.david.wei AT gmail.com
"""

from __future__ import print_function
import sys
import math
import logging
import subprocess

  
def systemcall(command, cmsg=True):
  logging.info('Running command: '+command)
  t=subprocess.Popen(command,stdout=subprocess.PIPE,stderr=subprocess.STDOUT,shell=True).communicate()[0].decode("utf-8")
  #tmsg=t.stdout.read()
  if cmsg:
    logging.info('Command message:')
    for t0 in t.split('\n'):
      logging.info('  '+t0)
    logging.info('End command message.')
  return t


def merge_rank_summary_files(lowfile,highfile,outfile,args,lowfile_prefix='',highfile_prefix=''):
  """
  Merge multiple rank summary files
  """
  gfile={}
  lowfileorder=[]
  lowfileheader=[]
  # read files individually
  nline=0
  for line in open(lowfile):
    field=line.strip().split()
    nline+=1
    if nline==1: # skip the first line
      lowfileheader=field
      lowfileheader[2:]=[lowfile_prefix+t for t in lowfileheader[2:]]
      continue
    if len(field)<4:
      logging.error('The number of fields in file '+lowfile+' is <4.')
      sys.exit(-1)
    gid=field[0]
    gitem=int(field[1])
    g_others=field[1:]
    gfile[gid]=[t for t in g_others]
    lowfileorder+=[gid]
  maxnline=nline
  nline=0
  njoinfield=0
  highfileheader=[]
  for line in open(highfile):
    field=line.strip().split()
    nline+=1
    if nline==1: # skip the first line
      highfileheader=field
      highfileheader[2:]=[highfile_prefix+t for t in highfileheader[2:]]
      continue
    if len(field)<4:
      logging.error('The number of fields in file '+highfile+' is <4.')
      sys.exit(-1)
    gid=field[0]
    gitem=int(field[1])
    g_others=field[2:]
    if gid not in gfile:
      logging.warning('Item '+gid+' appears in '+highfile+', but not in '+lowfile+'. This record will be omitted.')
    else:
      prevgitem=int(gfile[gid][0])
      if prevgitem!=gitem:
        logging.warning('Item number of '+gid+' does not match previous file: '+str(gitem)+' !='+str(prevgitem)+'.')
      gfile[gid]+=g_others # don't repeat the gitem
      njoinfield=len(gfile[gid])
  # check whether some items appear in the first group, but not in the second group
  keepsgs=[]
  for (k,v) in gfile.iteritems():
    if len(v)!=njoinfield:
      logging.warning('Item '+k+' appears in '+lowfile+', but not in '+highfile+'.')
    else:
      keepsgs+=[k]
  gfile2={k:gfile[k] for k in keepsgs}
  
  # write to files
  ofhd=open(outfile,'w')
  # print('\t'.join(['id','num','p.neg','fdr.neg','rank.neg','p.pos','fdr.pos','rank.pos']),file=ofhd)
  print('\t'.join(lowfileheader)+'\t'+'\t'.join(highfileheader[2:]),file=ofhd)
  for k in lowfileorder:
    if k in gfile2:
      print('\t'.join([k, '\t'.join([str(t) for t in gfile2[k]])]),file=ofhd)
  
  ofhd.close()
 


def merge_rank_files(lowfile,highfile,outfile,args):
  """
  Merge neg. and pos. selected files (generated by RRA) into one
  """
  gfile={}
  # read files individually
  nline=0
  for line in open(lowfile):
    field=line.strip().split()
    nline+=1
    if nline==1: # skip the first line
      continue
    if len(field)<4:
      logging.error('The number of fields in file '+lowfile+' is <4.')
      sys.exit(-1)
    gid=field[0]
    gitem=int(field[1])
    g_lo=float(field[2])
    g_p=float(field[3])
    g_fdr=float(field[4])
    g_goodsgrna=int(field[5])
    gfile[gid]=[[gitem,g_lo,g_p,g_fdr,nline-1,g_goodsgrna]]
  maxnline=nline
  nline=0
  for line in open(highfile):
    field=line.strip().split()
    nline+=1
    if nline==1: # skip the first line
      continue
    if len(field)<4:
      logging.error('The number of fields in file '+highfile+' is <4.')
      sys.exit(-1)
    gid=field[0]
    gitem=int(field[1])
    g_lo=float(field[2])
    g_p=float(field[3])
    g_fdr=float(field[4])
    g_goodsgrna=int(field[5])
    if gid not in gfile:
      logging.warning('Item '+gid+' appears in '+highfile+', but not in '+lowfile+'.')
      #gfile[gid]=[('NA',1.0,1.0,maxnline)]
      gfile[gid]=[[1.0,1.0,1.0,maxnline,0]] # note that gitem is not saved
    else:
      #gfile[gid]+=[(gitem,g_p,g_fdr,nline-1)]
      if gfile[gid][0][0]!=gitem:
        logging.warning('Item number of '+gid+' does not match previous file: '+str(gitem)+' !='+str(gfile[gid][0][0])+'.')
      gfile[gid]+=[[g_lo,g_p,g_fdr,nline-1,g_goodsgrna]] # don't repeat the gitem
  # check whether some items appear in the first group, but not in the second group
  for (k,v) in gfile.iteritems():
    if len(v)==1:
      logging.warning('Item '+gid+' appears in '+lowfile+', but not in '+highfile+'.')
      #gfile[gid]+=[('NA',1.0,1.0,maxnline)]
      gfile[gid]+=[[1.0,1.0,1.0,maxnline,0]]
  # write to files
  ofhd=open(outfile,'w')
  print('\t'.join(['id','num','neg|score','neg|p-value','neg|fdr','neg|rank','neg|goodsgrna','pos|score','pos|p-value','pos|fdr','pos|rank','pos|goodsgrna']),file=ofhd)
  if hasattr(args,'sort_criteria') and args.sort_criteria=='pos':
    logging.debug('Sorting the merged items by positive selection...')
    skey=sorted(gfile.items(),key=lambda x : x[1][1][0])
  else:
    logging.debug('Sorting the merged items by negative selection...')
    skey=sorted(gfile.items(),key=lambda x : x[1][0][1])
  # correct FDR method from RRA
  if hasattr(args,'adjust_method') and args.adjust_method!='fdr':
    from mageck.fdr_calculation import pFDR
    logging.debug('adjusting fdr using '+args.adjust_method+' method ...')
    pnegpool=[t[1][0][2] for t in skey] # negative selection: p-value is in item[2], fdr in item[3]
    ppospool=[t[1][1][1] for t in skey] # positive selection: p-value is in item[1], fdr in item[2]
    dfrnegpool=pFDR(pnegpool,method=args.adjust_method)
    dfrpospool=pFDR(ppospool,method=args.adjust_method)
    ind=0
    #import pdb 
    #pdb.set_trace()
    #
    skey2=[]
    for t in skey:
      t2=[t[0],t[1]]
      t2[1][0][3]=dfrnegpool[ind]
      t2[1][1][2]=dfrpospool[ind]
      ind+=1
      skey2+=[t2]
    skey=skey2
  # write to file
  for k in skey:
    print('\t'.join([k[0], '\t'.join([str(t) for t in k[1][0]+k[1][1]])]),file=ofhd)
  
  ofhd.close()
    
   

def parse_sampleids(samplelabel,ids):
  """
  Parse the label id according to the given sample labels
  Parameter: 
    samplelabel: a string of labels, like '0,2,3' or 'treat1,treat2,treat3'
    ids: a {samplelabel:index} ({string:int})
  Return:
    (a list of index, a list of index labels)
  """
  # labels
  idsk=[""]*len(ids)
  for (k,v) in ids.iteritems():
    idsk[v]=k
  if samplelabel == None:
    groupidslabel=(ids.keys())
    groupids=[ids[x] for x in groupidslabel]
    return (groupids,groupidslabel)
  
  try:
    groupids=[int(x) for x in samplelabel.split(',')]
    groupidslabel=[idsk[x] for x in groupids]
  except ValueError:
    groupidstr=samplelabel.split(',')
    groupids=[]
    groupidslabel=[]
    for gp in groupidstr:
      if gp not in ids:
        logging.error('Sample label '+gp+' does not match records in your count table.')
        logging.error('Sample labels in your count table: '+','.join(idsk))
        sys.exit(-1)
      groupids+=[ids[gp]]
      groupidslabel+=[idsk[ids[gp]]]
  logging.debug('Given sample labels: '+samplelabel)
  logging.debug('Converted index: '+' '.join([str(x) for x in groupids]))
  return  (groupids,groupidslabel)


